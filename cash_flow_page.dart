import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:intl/intl.dart';
import 'package:fl_chart/fl_chart.dart';

class CashFlowPage extends StatefulWidget {
  const CashFlowPage({super.key});

  @override
  State<CashFlowPage> createState() => _CashFlowPageState();
}

class _CashFlowPageState extends State<CashFlowPage> with TickerProviderStateMixin {
  static const _tabLabels = ['All', 'Payables', 'Transactions'];
  static const _snackBarDuration = Duration(seconds: 3);

  double _totalInflows = 0;
  double _totalOutflows = 0;
  double _currentCashBalance = 0;
  double _initialCapital = 0;
  late final String _uid;
  final _currency = NumberFormat.currency(symbol: '₱');
  bool _isLoading = true;
  String _errorMessage = '';
  late TabController _tabController;

  late final CollectionReference _usersCollection;
  late CollectionReference _cashFlowCollection;
  late CollectionReference _liabilitiesCollection;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: _tabLabels.length, vsync: this);
    _initializeFirebaseRefs();
    _initializeUser();
  }

  void _initializeFirebaseRefs() {
    _usersCollection = FirebaseFirestore.instance.collection('users');
  }

  void _initializeUser() {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) Navigator.of(context).pop();
      });
      return;
    }
    _uid = user.uid;
    _cashFlowCollection = _usersCollection.doc(_uid).collection('cashFlowEntries');
    _liabilitiesCollection = _usersCollection.doc(_uid).collection('liabilities');
    _loadData();
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  Future<void> _loadData() async {
    if (!mounted) return;
    setState(() {
      _isLoading = true;
      _errorMessage = '';
    });
    try {
      await Future.wait([
        _loadInitialCapital(),
        _loadCashFlowEntries(),
      ]);
    } catch (e) {
      if (mounted) {
        setState(() => _errorMessage = 'Failed to load data: $e');
      }
    } finally {
      if (mounted) setState(() => _isLoading = false);
    }
  }

  Future<void> _loadInitialCapital() async {
    try {
      final userDoc = await _usersCollection.doc(_uid).get();
      if (userDoc.exists) {
        _initialCapital = (userDoc.data() as Map<String, dynamic>?)?['initialCapital']?.toDouble() ?? 0;
      } else {
        await _usersCollection.doc(_uid).set({
          'initialCapital': 0,
          'createdAt': FieldValue.serverTimestamp(),
        });
        _initialCapital = 0;
      }
    } catch (_) {
      _initialCapital = 0;
    }
  }

  Future<void> _loadCashFlowEntries() async {
    final snapshot = await _cashFlowCollection.get();
    double inflow = 0, outflow = 0;
    for (final doc in snapshot.docs) {
      final data = doc.data() as Map<String, dynamic>;
      final amount = (data['amount'] as num?)?.toDouble() ?? 0;
      final type = (data['type'] as String?)?.toLowerCase() ?? '';
      if (type == 'inflow' && amount > 0) {
        inflow += amount;
      } else if (type == 'outflow' && amount > 0) {
        outflow += amount;
      }
    }
    if (mounted) {
      setState(() {
        _totalInflows = inflow;
        _totalOutflows = outflow;
        _currentCashBalance = _initialCapital + _totalInflows - _totalOutflows;
      });
    }
  }

  DateTime _computeBirDueDate(DateTime profitDate, String taxType) {
    final nextMonth = DateTime(profitDate.year, profitDate.month + 1, 1);
    if (taxType.toLowerCase().contains('vat')) {
      return DateTime(nextMonth.year, nextMonth.month, 25);
    } else {
      return DateTime(nextMonth.year, nextMonth.month, 20);
    }
  }

  void _showTransactionDetails(Map<String, dynamic> data) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        title: Text(data['description']?.toString() ?? 'Transaction'),
        content: SingleChildScrollView(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _detailRow('Type', (data['type'] as String?)?.toUpperCase() ?? 'N/A'),
              _detailRow('Amount', _currency.format((data['amount'] as num?)?.toDouble() ?? 0)),
              _detailRow('Category', data['category']?.toString() ?? 'Uncategorized'),
              if (data.containsKey('date')) _detailRow('Date', _formatTimestamp(data['date'] as Timestamp?)),
              if (data.containsKey('isAutogenerated')) _detailRow('Source', data['isAutogenerated'] == true ? 'Auto-generated' : 'Manual'),
              if (data.containsKey('relatedLiability')) _detailRow('Related Liability ID', data['relatedLiability']?.toString() ?? 'None'),
            ],
          ),
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context), child: const Text('Close')),
        ],
      ),
    );
  }

  void _showLiabilityDetails(Map<String, dynamic> data) {
    Timestamp? effectiveDueDate = data['dueDate'] as Timestamp?;
    final isTax = data['isTaxLiability'] == true;
    final createdTs = data['date'] as Timestamp?;
    if (isTax && effectiveDueDate == null && createdTs != null) {
      final computed = _computeBirDueDate(createdTs.toDate(), data['name']?.toString() ?? '');
      effectiveDueDate = Timestamp.fromDate(computed);
    }
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        title: Text(data['name']?.toString() ?? 'Liability'),
        content: SingleChildScrollView(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _detailRow('Type', data['type']?.toString() ?? 'Other'),
              _detailRow('Remaining Amount', _currency.format((data['amount'] as num?)?.toDouble() ?? 0)),
              if (effectiveDueDate != null) _detailRow('Due Date', _formatDateOnly(effectiveDueDate)),
              if (createdTs != null) _detailRow('Created', _formatDateOnly(createdTs)),
              if (data.containsKey('lastPaymentDate')) _detailRow('Last Payment', _formatTimestamp(data['lastPaymentDate'] as Timestamp?)),
              if (data.containsKey('lastPaymentAmount')) _detailRow('Last Payment Amount', _currency.format((data['lastPaymentAmount'] as num?)?.toDouble() ?? 0)),
            ],
          ),
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context), child: const Text('Close')),
        ],
      ),
    );
  }

  Widget _detailRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: RichText(
        text: TextSpan(
          children: [
            TextSpan(text: '$label: ', style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.black87)),
            TextSpan(text: value, style: const TextStyle(color: Colors.black54)),
          ],
        ),
      ),
    );
  }

  String _formatDateOnly(Timestamp? ts) {
    if (ts == null) return 'N/A';
    return DateFormat('dd-MMM-yyyy').format(ts.toDate());
  }

  String _formatTimestamp(Timestamp? ts) {
    final dt = (ts ?? Timestamp.now()).toDate();
    return DateFormat('dd-MMM-yyyy • h:mm a').format(dt);
  }

  Future<void> _processPayment({
    required String liabilityId,
    required String name,
    required double amount,
    required double remainingBalance,
  }) async {
    if (!mounted || amount <= 0 || amount > remainingBalance) {
      _showSnackBar('Invalid payment amount', SnackBarType.error);
      return;
    }
    _showSnackBar('Processing payment...', SnackBarType.loading);
    try {
      final batch = FirebaseFirestore.instance.batch();
      final outflowRef = _cashFlowCollection.doc();
      batch.set(outflowRef, {
        'description': 'Payment - $name',
        'amount': amount,
        'type': 'outflow',
        'category': _getCategoryForLiability(name),
        'date': Timestamp.now(),
        'createdAt': FieldValue.serverTimestamp(),
        'isManual': true,
        'isAutogenerated': false,
        'relatedLiability': liabilityId,
      });

      final liabilityRef = _liabilitiesCollection.doc(liabilityId);
      final newBalance = remainingBalance - amount;
      if (newBalance <= 0.001) {
        batch.delete(liabilityRef);
      } else {
        batch.update(liabilityRef, {
          'amount': newBalance,
          'lastPaymentDate': Timestamp.now(),
          'lastPaymentAmount': amount,
          'updatedAt': FieldValue.serverTimestamp(),
        });
      }
      await batch.commit();
      if (mounted) {
        ScaffoldMessenger.of(context).hideCurrentSnackBar();
        final message = newBalance <= 0.001
            ? '$name has been fully paid off!'
            : 'Payment of ${_currency.format(amount)} recorded successfully';
        _showSnackBar(message, SnackBarType.success);
        await _loadData();
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).hideCurrentSnackBar();
        _showSnackBar('Payment failed: $e', SnackBarType.error);
      }
    }
  }

  String _getCategoryForLiability(String name) {
    final lower = name.toLowerCase();
    if (lower.contains('loan') || lower.contains('mortgage')) return 'Loan Payment';
    if (lower.contains('tax')) return 'Tax Payment';
    if (lower.contains('credit')) return 'Credit Payment';
    if (lower.contains('utility') || lower.contains('electric') || lower.contains('water')) {
      return 'Utilities';
    }
    if (lower.contains('rent')) return 'Rent Payment';
    return 'Other Expenses';
  }

  Future<void> _deleteTransaction(String docId, Map<String, dynamic> data) async {
    if (data['isAutogenerated'] == true) {
      _showSnackBar('Auto-generated entries cannot be deleted', SnackBarType.error);
      return;
    }
    final confirmed = await _showConfirmationDialog(
      title: 'Delete Transaction',
      content: 'Are you sure you want to delete "${data['description']}"? This action cannot be undone.',
      confirmText: 'Delete',
      isDestructive: true,
    );
    if (confirmed && mounted) {
      try {
        await _cashFlowCollection.doc(docId).delete();
        _showSnackBar('Transaction deleted successfully', SnackBarType.success);
        await _loadData();
      } catch (e) {
        _showSnackBar('Failed to delete transaction: $e', SnackBarType.error);
      }
    }
  }

  Future<bool> _showConfirmationDialog({
    required String title,
    required String content,
    String confirmText = 'Confirm',
    bool isDestructive = false,
  }) async {
    final result = await showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        title: Text(title),
        content: Text(content),
        actions: [
          TextButton(onPressed: () => Navigator.of(context).pop(false), child: const Text('Cancel')),
          ElevatedButton(
            style: ElevatedButton.styleFrom(
              backgroundColor: isDestructive ? Colors.red[600] : Colors.blue[600],
              foregroundColor: Colors.white,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
            ),
            onPressed: () => Navigator.of(context).pop(true),
            child: Text(confirmText),
          ),
        ],
      ),
    );
    return result ?? false;
  }

  Future<void> _showPaymentDialog({
    required String liabilityId,
    required String name,
    required double remaining,
    required String type,
  }) async {
    if (remaining <= 0.001) {
      _showSnackBar('This liability is already paid off', SnackBarType.info);
      return;
    }
    final selectedAmount = await showModalBottomSheet<double>(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => _PaymentBottomSheet(name: name, remaining: remaining, currency: _currency),
    );
    if (selectedAmount != null && selectedAmount > 0 && mounted) {
      final confirmed = await _showPaymentConfirmation(
        name: name,
        amount: selectedAmount,
        remainingBalance: remaining,
      );
      if (confirmed) {
        await _processPayment(
          liabilityId: liabilityId,
          name: name,
          amount: selectedAmount,
          remainingBalance: remaining,
        );
      }
    }
  }

  Future<bool> _showPaymentConfirmation({
    required String name,
    required double amount,
    required double remainingBalance,
  }) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        title: Row(
          children: [
            Icon(Icons.payment, color: Colors.blue[600], size: 24),
            const SizedBox(width: 12),
            const Text('Confirm Payment'),
          ],
        ),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('You are about to pay:', style: TextStyle(color: Colors.grey[600])),
            const SizedBox(height: 12),
            Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: Colors.grey[50],
                borderRadius: BorderRadius.circular(12),
                border: Border.all(color: Colors.grey[200]!),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(name, style: const TextStyle(fontWeight: FontWeight.w600, fontSize: 16)),
                  const SizedBox(height: 8),
                  Text('Payment Amount: ${_currency.format(amount)}', style: TextStyle(color: Colors.green[700], fontWeight: FontWeight.w500)),
                  Text('Remaining After Payment: ${_currency.format(remainingBalance - amount)}', style: TextStyle(color: Colors.grey[600])),
                ],
              ),
            ),
            if (amount > _currentCashBalance) ...[
              const SizedBox(height: 12),
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.orange[50],
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(color: Colors.orange[200]!),
                ),
                child: Row(
                  children: [
                    Icon(Icons.warning_amber, color: Colors.orange[700], size: 20),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        'This payment exceeds your current cash balance of ${_currency.format(_currentCashBalance)}.',
                        style: TextStyle(color: Colors.orange[700], fontSize: 13),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ],
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context, false), child: const Text('Cancel')),
          ElevatedButton(
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.blue[600],
              foregroundColor: Colors.white,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
            ),
            onPressed: () => Navigator.pop(context, true),
            child: const Text('Confirm Payment'),
          ),
        ],
      ),
    );
    return confirmed ?? false;
  }

  void _showSnackBar(String message, SnackBarType type) {
    if (!mounted) return;
    final config = _getSnackBarConfig(type);
    ScaffoldMessenger.of(context).clearSnackBars();
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Row(
          children: [
            if (config.icon != null) ...[
              config.isLoading
                  ? const SizedBox(width: 16, height: 16, child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white))
                  : Icon(config.icon, color: Colors.white, size: 20),
              const SizedBox(width: 12),
            ],
            Expanded(child: Text(message)),
          ],
        ),
        backgroundColor: config.color,
        behavior: config.isLoading ? SnackBarBehavior.fixed : SnackBarBehavior.floating,
        shape: config.isLoading
            ? null
            : RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        margin: config.isLoading ? null : const EdgeInsets.all(16),
        duration: config.isLoading ? const Duration(minutes: 1) : _snackBarDuration,
      ),
    );
  }

  _SnackBarConfig _getSnackBarConfig(SnackBarType type) {
    switch (type) {
      case SnackBarType.success:
        return _SnackBarConfig(icon: Icons.check_circle, color: Colors.green[600]!);
      case SnackBarType.error:
        return _SnackBarConfig(icon: Icons.error_outline, color: Colors.red[600]!);
      case SnackBarType.info:
        return _SnackBarConfig(icon: Icons.info_outline, color: Colors.blue[600]!);
      case SnackBarType.loading:
        return _SnackBarConfig(icon: Icons.hourglass_empty, color: Colors.blue[600]!, isLoading: true);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.grey[50],
      appBar: AppBar(
        title: const Text('Cash Flow', style: TextStyle(fontWeight: FontWeight.w600)),
        backgroundColor: Colors.white,
        foregroundColor: Colors.black87,
        elevation: 0,
        bottom: PreferredSize(
          preferredSize: const Size.fromHeight(1),
          child: Container(height: 1, color: Colors.grey[200]),
        ),
        actions: [
          IconButton(
            tooltip: 'Refresh',
            onPressed: _isLoading ? null : _loadData,
            icon: _isLoading
                ? SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2, color: Colors.blue[600]))
                : const Icon(Icons.refresh_rounded),
          ),
        ],
      ),
      body: _buildBody(),
    );
  }

  Widget _buildBody() {
    if (_isLoading) return const Center(child: CircularProgressIndicator());
    if (_errorMessage.isNotEmpty) {
      return _buildErrorState(message: _errorMessage, onRetry: _loadData);
    }
    return RefreshIndicator(
      onRefresh: _loadData,
      color: Colors.blue[600],
      child: Column(
        children: [
          _buildSummarySection(),
          _buildTabBar(),
          Expanded(child: _buildTabBarView()),
        ],
      ),
    );
  }

  Widget _buildSummarySection() {
    final isPositive = _currentCashBalance >= 0;
    final total = _totalInflows + _totalOutflows;
    final inflowPercent = total > 0 ? (_totalInflows / total * 100).round() : 0;
    final outflowPercent = total > 0 ? (_totalOutflows / total * 100).round() : 0;
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            width: double.infinity,
            padding: const EdgeInsets.symmetric(vertical: 14, horizontal: 18),
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(16),
              gradient: LinearGradient(
                colors: isPositive
                    ? [Colors.blue[600]!, Colors.blue[400]!]
                    : [Colors.red[600]!, Colors.red[400]!],
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
              ),
              boxShadow: [
                BoxShadow(
                  color: (isPositive ? Colors.blue[200]! : Colors.red[200]!).withAlpha((0.6 * 255).round()),
                  blurRadius: 12,
                  offset: const Offset(0, 4),
                ),
              ],
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Container(
                      padding: const EdgeInsets.all(6),
                      decoration: BoxDecoration(color: Colors.white24, borderRadius: BorderRadius.circular(8)),
                      child: Icon(
                        isPositive ? Icons.account_balance_wallet : Icons.warning_rounded,
                        color: Colors.white,
                        size: 18,
                      ),
                    ),
                    const Spacer(),
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 3),
                      decoration: BoxDecoration(color: Colors.white24, borderRadius: BorderRadius.circular(10)),
                      child: Text(
                        isPositive ? 'Healthy' : 'Deficit',
                        style: const TextStyle(color: Colors.white, fontSize: 10, fontWeight: FontWeight.w600),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 8),
                const Text('Current Cash Balance', style: TextStyle(color: Colors.white70, fontSize: 12, fontWeight: FontWeight.w500)),
                const SizedBox(height: 2),
                Text(
                  _currency.format(_currentCashBalance),
                  style: const TextStyle(color: Colors.white, fontSize: 20, fontWeight: FontWeight.bold),
                ),
              ],
            ),
          ),
          const SizedBox(height: 16),
          SizedBox(
            height: 140,
            child: PieChart(
              PieChartData(
                sectionsSpace: 0,
                centerSpaceRadius: 40,
                sections: [
                  PieChartSectionData(
                    color: Colors.green[600],
                    value: _totalInflows,
                    title: total > 0 && _totalInflows > 0 ? '$inflowPercent%' : '',
                    radius: 40,
                    titleStyle: const TextStyle(fontSize: 12, fontWeight: FontWeight.bold, color: Colors.white),
                  ),
                  PieChartSectionData(
                    color: Colors.red[600],
                    value: _totalOutflows,
                    title: total > 0 && _totalOutflows > 0 ? '$outflowPercent%' : '',
                    radius: 40,
                    titleStyle: const TextStyle(fontSize: 12, fontWeight: FontWeight.bold, color: Colors.white),
                  ),
                ],
                pieTouchData: PieTouchData(),
              ),
            ),
          ),
          const SizedBox(height: 12),
          Row(
            children: [
              Expanded(
                child: _summaryCard(
                  title: 'Total Inflows',
                  amount: _totalInflows,
                  icon: Icons.trending_up_rounded,
                  color: Colors.green,
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: _summaryCard(
                  title: 'Total Outflows',
                  amount: _totalOutflows,
                  icon: Icons.trending_down_rounded,
                  color: Colors.red,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _summaryCard({
    required String title,
    required double amount,
    required IconData icon,
    required MaterialColor color,
  }) {
    return Container(
      padding: const EdgeInsets.all(14),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(14),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withAlpha((0.05 * 255).round()),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            padding: const EdgeInsets.all(6),
            decoration: BoxDecoration(color: color[50], borderRadius: BorderRadius.circular(8)),
            child: Icon(icon, color: color[600], size: 18),
          ),
          const SizedBox(height: 8),
          Text(
            title,
            style: TextStyle(fontSize: 11, color: Colors.grey[600], fontWeight: FontWeight.w500),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 4),
          Text(
            _currency.format(amount),
            style: TextStyle(fontSize: 14, fontWeight: FontWeight.bold, color: color[700]),
          ),
        ],
      ),
    );
  }

  Widget _buildTabBar() {
    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 20),
      padding: const EdgeInsets.all(4),
      decoration: BoxDecoration(color: Colors.grey[100], borderRadius: BorderRadius.circular(12)),
      child: TabBar(
        controller: _tabController,
        indicator: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(8),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withAlpha((0.1 * 255).round()),
              blurRadius: 8,
              offset: const Offset(0, 2),
            ),
          ],
        ),
        indicatorPadding: const EdgeInsets.all(2),
        labelColor: Colors.black87,
        unselectedLabelColor: Colors.grey[600],
        labelStyle: const TextStyle(fontWeight: FontWeight.w600, fontSize: 14),
        unselectedLabelStyle: const TextStyle(fontWeight: FontWeight.w500, fontSize: 14),
        tabs: _tabLabels.map((label) => Tab(text: label)).toList(),
      ),
    );
  }

  Widget _buildTabBarView() {
    return Padding(
      padding: const EdgeInsets.only(top: 16),
      child: TabBarView(
        controller: _tabController,
        children: [
          _allTab(),
          _payablesTab(),
          _transactionsTab(),
        ],
      ),
    );
  }

  Widget _allTab() {
    return StreamBuilder<QuerySnapshot>(
      stream: _cashFlowCollection.orderBy('date', descending: true).snapshots(),
      builder: (context, cashSnapshot) {
        return StreamBuilder<QuerySnapshot>(
          stream: _liabilitiesCollection.snapshots(),
          builder: (context, liabilitySnapshot) {
            if (cashSnapshot.hasError || liabilitySnapshot.hasError) {
              return _buildErrorState(message: 'Error loading data', onRetry: _loadData);
            }
            if (cashSnapshot.connectionState == ConnectionState.waiting ||
                liabilitySnapshot.connectionState == ConnectionState.waiting) {
              return const Center(child: CircularProgressIndicator());
            }
            final cashDocs = cashSnapshot.data?.docs ?? [];
            final liabilityDocs = liabilitySnapshot.data?.docs ?? [];
            final allItems = <Map<String, dynamic>>[];

            allItems.addAll(cashDocs.map((doc) {
              final data = doc.data() as Map<String, dynamic>;
              return {
                'id': doc.id,
                'type': 'transaction',
                'data': data,
                'date': data['date'] as Timestamp? ?? Timestamp.now(),
              };
            }));

            allItems.addAll(liabilityDocs.where((doc) {
              final data = doc.data() as Map<String, dynamic>;
              final amount = (data['amount'] as num?)?.toDouble() ?? 0;
              return amount > 0.001;
            }).map((doc) {
              final originalData = doc.data() as Map<String, dynamic>;
              final displayData = Map<String, dynamic>.from(originalData);
              Timestamp? effectiveDue = originalData['dueDate'] as Timestamp?;
              if (originalData['isTaxLiability'] == true && effectiveDue == null) {
                final created = originalData['date'] as Timestamp?;
                if (created != null) {
                  final computed = _computeBirDueDate(created.toDate(), originalData['name']?.toString() ?? '');
                  effectiveDue = Timestamp.fromDate(computed);
                  displayData['dueDate'] = effectiveDue;
                }
              }
              return {
                'id': doc.id,
                'type': 'liability',
                'data': displayData,
                'date': effectiveDue ?? (originalData['date'] as Timestamp?) ?? Timestamp.now(),
              };
            }));

            if (allItems.isEmpty) {
              return _buildEmptyState(
                icon: Icons.inbox_rounded,
                title: 'No activity yet',
                subtitle: 'Your transactions and payables will appear here',
              );
            }

            allItems.sort((a, b) => (b['date'] as Timestamp).compareTo(a['date'] as Timestamp));
            return ListView.separated(
              padding: const EdgeInsets.fromLTRB(16, 0, 16, 100),
              itemCount: allItems.length,
              separatorBuilder: (context, index) => const SizedBox(height: 8),
              itemBuilder: (context, index) {
                final item = allItems[index];
                if (item['type'] == 'transaction') {
                  return _transactionCard(
                    item: item['data'],
                    onDelete: () => _deleteTransaction(item['id'] as String, item['data']),
                    onTap: () => _showTransactionDetails(item['data']),
                  );
                } else {
                  final data = item['data'] as Map<String, dynamic>;
                  return _liabilityCard(
                    item: data,
                    currency: _currency,
                    onPay: () => _showPaymentDialog(
                      liabilityId: item['id'] as String,
                      name: data['name'] ?? 'Unnamed',
                      remaining: (data['amount'] as num?)?.toDouble() ?? 0,
                      type: data['type'] ?? 'Other',
                    ),
                    onTap: () => _showLiabilityDetails(data),
                  );
                }
              },
            );
          },
        );
      },
    );
  }

  Widget _payablesTab() {
    return StreamBuilder<QuerySnapshot>(
      stream: _liabilitiesCollection.snapshots(),
      builder: (context, snapshot) {
        if (snapshot.hasError) {
          return _buildErrorState(message: 'Error loading payables', onRetry: _loadData);
        }
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        }
        final docs = snapshot.data?.docs ?? [];
        final payableDocs = docs.where((doc) {
          final data = doc.data() as Map<String, dynamic>;
          final amount = (data['amount'] as num?)?.toDouble() ?? 0;
          return amount > 0.001;
        }).toList();

        final payableItems = payableDocs.map((doc) {
          final data = doc.data() as Map<String, dynamic>;
          Timestamp? effectiveDue = data['dueDate'] as Timestamp?;
          if (data['isTaxLiability'] == true && effectiveDue == null) {
            final created = data['date'] as Timestamp?;
            if (created != null) {
              final computed = _computeBirDueDate(created.toDate(), data['name']?.toString() ?? '');
              effectiveDue = Timestamp.fromDate(computed);
            }
          }
          return {'doc': doc, 'effectiveDue': effectiveDue};
        }).toList();

        payableItems.sort((a, b) {
          final dueA = a['effectiveDue'] as Timestamp?;
          final dueB = b['effectiveDue'] as Timestamp?;
          const farFuture = Duration(days: 365 * 100);
          final effectiveDueA = dueA?.toDate() ?? DateTime.now().add(farFuture);
          final effectiveDueB = dueB?.toDate() ?? DateTime.now().add(farFuture);
          return effectiveDueA.compareTo(effectiveDueB);
        });

        if (payableItems.isEmpty) {
          return _buildEmptyState(
            icon: Icons.request_page_rounded,
            title: 'No payables',
            subtitle: 'Your upcoming payments (e.g., taxes, loans) will appear here',
          );
        }

        return ListView.separated(
          padding: const EdgeInsets.fromLTRB(16, 0, 16, 100),
          itemCount: payableItems.length,
          separatorBuilder: (context, index) => const SizedBox(height: 8),
          itemBuilder: (context, index) {
            final item = payableItems[index];
            final doc = item['doc'] as QueryDocumentSnapshot;
            final effectiveDue = item['effectiveDue'] as Timestamp?;
            final data = doc.data() as Map<String, dynamic>;
            final displayData = Map<String, dynamic>.from(data);
            if (effectiveDue != null && !data.containsKey('dueDate')) {
              displayData['dueDate'] = effectiveDue;
            }
            return _liabilityCard(
              item: displayData,
              currency: _currency,
              onPay: () => _showPaymentDialog(
                liabilityId: doc.id,
                name: data['name'] ?? 'Unnamed',
                remaining: (data['amount'] as num?)?.toDouble() ?? 0,
                type: data['type'] ?? 'Other',
              ),
              onTap: () => _showLiabilityDetails(displayData),
            );
          },
        );
      },
    );
  }

  Widget _transactionsTab() {
    return StreamBuilder<QuerySnapshot>(
      stream: _cashFlowCollection.orderBy('date', descending: true).snapshots(),
      builder: (context, snapshot) {
        if (snapshot.hasError) {
          return _buildErrorState(message: 'Error loading transactions', onRetry: _loadData);
        }
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        }
        final docs = snapshot.data?.docs ?? [];
        if (docs.isEmpty) {
          return _buildEmptyState(
            icon: Icons.receipt_long_rounded,
            title: 'No transactions',
            subtitle: 'Your transaction history will appear here',
          );
        }
        return ListView.separated(
          padding: const EdgeInsets.fromLTRB(16, 0, 16, 100),
          itemCount: docs.length,
          separatorBuilder: (context, index) => const SizedBox(height: 8),
          itemBuilder: (context, index) {
            final doc = docs[index];
            final data = doc.data() as Map<String, dynamic>;
            return _transactionCard(
              item: data,
              onDelete: () => _deleteTransaction(doc.id, data),
              onTap: () => _showTransactionDetails(data),
            );
          },
        );
      },
    );
  }

  Widget _transactionCard({
    required Map<String, dynamic> item,
    required VoidCallback onDelete,
    required VoidCallback onTap,
  }) {
    final amount = (item['amount'] as num?)?.toDouble() ?? 0;
    final isInflow = (item['type']?.toString().toLowerCase() ?? '') == 'inflow';
    final isAuto = item['isAutogenerated'] == true;
    final description = item['description']?.toString() ?? 'No description';
    final category = item['category']?.toString() ?? 'Uncategorized';
    final ts = item['date'] as Timestamp?;
    final dateStr = _formatTimestamp(ts);
    final Color baseColor = isAuto ? Colors.purple : (isInflow ? Colors.green : Colors.red);

    return Material(
      color: Colors.white,
      borderRadius: BorderRadius.circular(16),
      elevation: 1,
      shadowColor: Colors.black.withAlpha((0.05 * 255).round()),
      child: InkWell(
        borderRadius: BorderRadius.circular(16),
        onTap: onTap,
        onLongPress: isAuto ? null : onDelete,
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: baseColor[50],
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Icon(
                  isAuto ? Icons.bolt_rounded : (isInflow ? Icons.arrow_downward_rounded : Icons.arrow_upward_rounded),
                  color: baseColor[600],
                  size: 20,
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(description, style: const TextStyle(fontWeight: FontWeight.w600, fontSize: 15), maxLines: 1, overflow: TextOverflow.ellipsis),
                    const SizedBox(height: 4),
                    Row(
                      children: [
                        Flexible(
                          child: Container(
                            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                            decoration: BoxDecoration(
                              color: Colors.grey[100],
                              borderRadius: BorderRadius.circular(8),
                            ),
                            child: Text(category, style: TextStyle(fontSize: 11, color: Colors.grey[700]), overflow: TextOverflow.ellipsis),
                          ),
                        ),
                        const SizedBox(width: 8),
                        Flexible(
                          child: Text(dateStr, style: TextStyle(fontSize: 12, color: Colors.grey[600]), overflow: TextOverflow.ellipsis),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
              const SizedBox(width: 12),
              Column(
                crossAxisAlignment: CrossAxisAlignment.end,
                children: [
                  Text(
                    '${isInflow ? '+' : '-'}${_currency.format(amount)}',
                    style: TextStyle(fontWeight: FontWeight.w700, color: isInflow ? Colors.green[700] : Colors.red[700]),
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 4),
                  if (isAuto)
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                      decoration: BoxDecoration(
                        color: Colors.purple[50],
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Text('Auto', style: TextStyle(color: Colors.purple[700], fontSize: 10)),
                    ),
                ],
              ),
              if (!isAuto) ...[
                const SizedBox(width: 4),
                SizedBox(
                  width: 36,
                  child: IconButton(
                    tooltip: 'Delete',
                    onPressed: onDelete,
                    icon: Icon(Icons.delete_outline_rounded, color: Colors.red[400], size: 20),
                    padding: EdgeInsets.zero,
                    constraints: const BoxConstraints(minWidth: 36, minHeight: 36),
                  ),
                ),
              ]
            ],
          ),
        ),
      ),
    );
  }

  Widget _liabilityCard({
    required Map<String, dynamic> item,
    required VoidCallback onPay,
    required NumberFormat currency,
    required VoidCallback onTap,
  }) {
    final name = (item['name']?.toString() ?? 'Unnamed').trim();
    final type = (item['type']?.toString() ?? 'Other').trim();
    final remaining = (item['amount'] as num?)?.toDouble() ?? 0.0;
    final dueTs = item['dueDate'] as Timestamp?;
    final createdTs = item['date'] as Timestamp?;
    final when = dueTs ?? createdTs;
    final whenStr = when != null ? DateFormat('dd-MMM-yyyy').format(when.toDate()) : 'No date';
    final now = DateTime.now();
    final dueDate = when?.toDate();
    final isOverdue = dueDate != null && dueDate.isBefore(DateTime(now.year, now.month, now.day));
    final isSoon = !isOverdue && dueDate != null && dueDate.difference(now).inDays <= 7;

    Color chipBg, chipFg;
    String chipText;
    if (isOverdue) {
      chipBg = Colors.red[50]!;
      chipFg = Colors.red[700]!;
      chipText = 'Overdue';
    } else if (isSoon) {
      chipBg = Colors.orange[50]!;
      chipFg = Colors.orange[700]!;
      chipText = 'Due soon';
    } else {
      chipBg = Colors.blue[50]!;
      chipFg = Colors.blue[700]!;
      chipText = 'Upcoming';
    }

    return Material(
      color: Colors.white,
      borderRadius: BorderRadius.circular(16),
      elevation: 1,
      shadowColor: Colors.black.withAlpha((0.05 * 255).round()),
      child: InkWell(
        borderRadius: BorderRadius.circular(16),
        onTap: onTap,
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.amber[50],
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Icon(Icons.request_page_rounded, color: Colors.amber[700], size: 20),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(name, style: const TextStyle(fontWeight: FontWeight.w600, fontSize: 15), maxLines: 1, overflow: TextOverflow.ellipsis),
                    const SizedBox(height: 6),
                    Row(
                      children: [
                        Flexible(
                          child: Container(
                            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                            decoration: BoxDecoration(
                              color: Colors.grey[100],
                              borderRadius: BorderRadius.circular(8),
                            ),
                            child: Text(type, style: TextStyle(fontSize: 11, color: Colors.grey[700]), overflow: TextOverflow.ellipsis),
                          ),
                        ),
                        const SizedBox(width: 8),
                        Flexible(
                          child: Container(
                            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                            decoration: BoxDecoration(
                              color: chipBg,
                              borderRadius: BorderRadius.circular(8),
                            ),
                            child: Text(chipText, style: TextStyle(fontSize: 11, color: chipFg), overflow: TextOverflow.ellipsis),
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 6),
                    Text('${dueTs != null ? 'Due' : 'Created'}: $whenStr', style: TextStyle(color: Colors.grey[600], fontSize: 12)),
                  ],
                ),
              ),
              const SizedBox(width: 12),
              Column(
                crossAxisAlignment: CrossAxisAlignment.end,
                children: [
                  Text(
                    currency.format(remaining),
                    style: TextStyle(
                      fontWeight: FontWeight.w700,
                      color: isOverdue ? Colors.red[700] : (isSoon ? Colors.orange[700] : Colors.blue[700]),
                    ),
                  ),
                  const SizedBox(height: 6),
                  ElevatedButton.icon(
                    onPressed: remaining <= 0.001 ? null : onPay,
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.blue[600],
                      foregroundColor: Colors.white,
                      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
                      elevation: 0,
                    ),
                    icon: const Icon(Icons.payment_rounded, size: 16),
                    label: const Text('Pay'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildErrorState({required String message, required VoidCallback onRetry}) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 32),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(Icons.error_outline_rounded, color: Colors.red[400], size: 48),
            const SizedBox(height: 12),
            const Text('Something went wrong', style: TextStyle(fontWeight: FontWeight.w600, fontSize: 16)),
            const SizedBox(height: 6),
            Text(message, textAlign: TextAlign.center, style: TextStyle(color: Colors.grey[600])),
            const SizedBox(height: 12),
            ElevatedButton.icon(
              onPressed: onRetry,
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue[600],
                foregroundColor: Colors.white,
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
              ),
              icon: const Icon(Icons.refresh_rounded, size: 18),
              label: const Text('Retry'),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildEmptyState({required IconData icon, required String title, required String subtitle}) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 32),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, color: Colors.grey[400], size: 48),
            const SizedBox(height: 12),
            Text(title, style: const TextStyle(fontWeight: FontWeight.w600, fontSize: 16)),
            const SizedBox(height: 6),
            Text(subtitle, textAlign: TextAlign.center, style: TextStyle(color: Colors.grey[600])),
          ],
        ),
      ),
    );
  }
}

extension on Color {
  Color? operator [](int other) => null;
}

enum SnackBarType { success, error, info, loading }

class _SnackBarConfig {
  final IconData? icon;
  final Color color;
  final bool isLoading;
  _SnackBarConfig({required this.icon, required this.color, this.isLoading = false});
}

class _PaymentBottomSheet extends StatefulWidget {
  final String name;
  final double remaining;
  final NumberFormat currency;
  const _PaymentBottomSheet({required this.name, required this.remaining, required this.currency});

  @override
  State<_PaymentBottomSheet> createState() => _PaymentBottomSheetState();
}

class _PaymentBottomSheetState extends State<_PaymentBottomSheet> {
  final TextEditingController _controller = TextEditingController();
  String _errorText = '';
  double _amount = 0;

  @override
  void initState() {
    super.initState();
    _controller.addListener(_validate);
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _validate() {
    final text = _controller.text.replaceAll(',', '').trim();
    final value = double.tryParse(text) ?? 0;
    String error = '';
    if (value <= 0) {
      error = 'Enter a valid amount';
    } else if (value > widget.remaining + 0.0001) {
      error = 'Amount exceeds remaining balance';
    }
    setState(() {
      _amount = value;
      _errorText = error;
    });
  }

  void _submit() {
    _validate();
    if (_errorText.isEmpty && _amount > 0) {
      Navigator.pop<double>(context, _amount);
    }
  }

  @override
  Widget build(BuildContext context) {
    final viewInsets = MediaQuery.of(context).viewInsets.bottom;
    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTap: () => FocusScope.of(context).unfocus(),
      child: Padding(
        padding: EdgeInsets.only(bottom: viewInsets),
        child: Container(
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: const BorderRadius.only(
              topLeft: Radius.circular(16),
              topRight: Radius.circular(16),
            ),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withAlpha((0.15 * 255).round()),
                blurRadius: 16,
                offset: const Offset(0, -4),
              ),
            ],
          ),
          child: SafeArea(
            top: false,
            child: Padding(
              padding: const EdgeInsets.fromLTRB(20, 16, 20, 16),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Container(
                    width: 44,
                    height: 5,
                    decoration: BoxDecoration(
                      color: Colors.grey[300],
                      borderRadius: BorderRadius.circular(3),
                    ),
                  ),
                  const SizedBox(height: 16),
                  Row(
                    children: [
                      Icon(Icons.payment_rounded, color: Colors.blue[600]),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text('Pay ${widget.name}', style: const TextStyle(fontWeight: FontWeight.w700, fontSize: 16)),
                      ),
                    ],
                  ),
                  const SizedBox(height: 12),
                  Align(
                    alignment: Alignment.centerLeft,
                    child: Text('Remaining balance: ${widget.currency.format(widget.remaining)}', style: TextStyle(color: Colors.grey[700])),
                  ),
                  const SizedBox(height: 12),
                  TextField(
                    controller: _controller,
                    keyboardType: const TextInputType.numberWithOptions(decimal: true),
                    decoration: InputDecoration(
                      labelText: 'Amount',
                      prefixText: '₱ ',
                      errorText: _errorText.isEmpty ? null : _errorText,
                      filled: true,
                      fillColor: Colors.grey[50],
                      border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
                    ),
                    onSubmitted: (_) => _submit(),
                  ),
                  const SizedBox(height: 12),
                  Row(
                    children: [
                      Expanded(
                        child: OutlinedButton(
                          onPressed: () => Navigator.pop(context),
                          style: OutlinedButton.styleFrom(
                            foregroundColor: Colors.grey[800],
                            side: BorderSide(color: Colors.grey[300]!),
                            padding: const EdgeInsets.symmetric(vertical: 12),
                            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
                          ),
                          child: const Text('Cancel'),
                        ),
                      ),
                      const SizedBox(width: 12),
                      Expanded(
                        child: ElevatedButton(
                          onPressed: _errorText.isEmpty && _amount > 0 ? _submit : null,
                          style: ElevatedButton.styleFrom(
                            backgroundColor: Colors.blue[600],
                            foregroundColor: Colors.white,
                            padding: const EdgeInsets.symmetric(vertical: 12),
                            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
                          ),
                          child: const Text('Continue'),
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}